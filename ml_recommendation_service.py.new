"""
ML Recommendation Service for Library App
Provides machine learning-based book recommendations using collaborative filtering, content-based filtering,
and popularity-based recommendations.
"""
import sqlite3
import numpy as np
import pandas as pd
from typing import List, Dict, Any
from collections import defaultdict
from datetime import datetime
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer

class MLRecommendationService:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.vectorizer = TfidfVectorizer(stop_words='english')
        
    def get_db_connection(self):
        """Get SQLite database connection"""
        return sqlite3.connect(self.db_path)
        
    def get_popular_books(self, n: int = 10) -> List[Dict[str, Any]]:
        """Get most popular books based on borrow count"""
        conn = self.get_db_connection()
        cursor = conn.cursor()
        
        try:
            # Get books with highest borrow count
            cursor.execute("""
                SELECT b.id, b.title, b.author, b.category, b.description,
                       b.publication_year, b.isbn, b.available_copies, b.total_copies,
                       COUNT(bl.id) as borrow_count
                FROM books b
                LEFT JOIN book_loans bl ON b.id = bl.book_id
                GROUP BY b.id
                ORDER BY borrow_count DESC
                LIMIT ?
            """, (n,))
            
            popular_books = []
            for row in cursor.fetchall():
                popular_books.append({
                    'id': row[0],
                    'title': row[1],
                    'author': row[2],
                    'category': row[3],
                    'description': row[4] or 'No description available',
                    'publication_year': row[5],
                    'isbn': row[6],
                    'available_copies': row[7],
                    'total_copies': row[8],
                    'popularity_score': row[9]
                })
                
            return popular_books
        except sqlite3.Error:
            # Fallback to random books if query fails
            cursor.execute("""
                SELECT id, title, author, category, description,
                       publication_year, isbn, available_copies, total_copies
                FROM books 
                ORDER BY RANDOM() 
                LIMIT ?
            """, (n,))
            
            popular_books = []
            for row in cursor.fetchall():
                popular_books.append({
                    'id': row[0],
                    'title': row[1],
                    'author': row[2],
                    'category': row[3],
                    'description': row[4] or 'No description available',
                    'publication_year': row[5],
                    'isbn': row[6],
                    'available_copies': row[7],
                    'total_copies': row[8],
                    'popularity_score': 0
                })
                
            return popular_books
        finally:
            conn.close()
    
    def get_user_history(self, user_id: int) -> List[int]:
        """Get books previously borrowed by the user"""
        conn = self.get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT DISTINCT book_id 
            FROM book_loans
            WHERE user_id = ?
        """, (user_id,))
        
        borrowed_books = [row[0] for row in cursor.fetchall()]
        conn.close()
        
        return borrowed_books
    
    def get_book_features(self) -> Dict[int, Dict[str, Any]]:
        """Get book features for content-based filtering"""
        conn = self.get_db_connection()
        
        # Get all books with their features
        df = pd.read_sql_query("""
            SELECT id, title, author, category, description, publication_year
            FROM books
        """, conn)
        
        conn.close()
        
        # Create feature dictionary
        book_features = {}
        for _, row in df.iterrows():
            # Combine text features for TF-IDF
            text_features = f"{row['title']} {row['author']} {row['category']} {row['description'] or ''}"
            
            book_features[row['id']] = {
                'text': text_features,
                'year': row['publication_year'] or 0,
                'category': row['category']
            }
            
        return book_features

    def content_based_recommendations(self, user_id: int, n: int = 5) -> List[Dict[str, Any]]:
        """Generate content-based recommendations based on user's borrowing history"""
        # Get user's borrowing history
        user_history = self.get_user_history(user_id)
        
        if not user_history:
            # If no history, return popular books
            return self.get_popular_books(n)
            
        # Get all books and their features
        book_features = self.get_book_features()
        
        # Extract book IDs and text features for TF-IDF
        book_ids = list(book_features.keys())
        text_features = [book_features[bid]['text'] for bid in book_ids]
        
        # Create TF-IDF matrix
        try:
            tfidf_matrix = self.vectorizer.fit_transform(text_features)
            
            # Calculate similarity between all books
            similarity_matrix = cosine_similarity(tfidf_matrix)
            
            # Map book IDs to matrix indices
            book_indices = {book_id: idx for idx, book_id in enumerate(book_ids)}
            
            # Calculate similarity scores for each book based on user history
            scores = defaultdict(float)
            
            for book_id in user_history:
                if book_id in book_indices:
                    idx = book_indices[book_id]
                    for other_id, other_idx in book_indices.items():
                        # Don't recommend books the user has already read
                        if other_id not in user_history:
                            scores[other_id] += similarity_matrix[idx, other_idx]
            
            # Sort books by similarity score
            recommended_ids = sorted(scores.keys(), key=lambda x: scores[x], reverse=True)[:n]
            
            # Get book details
            conn = self.get_db_connection()
            cursor = conn.cursor()
            
            recommendations = []
            for book_id in recommended_ids:
                cursor.execute("""
                    SELECT id, title, author, category, description,
                           publication_year, isbn, available_copies, total_copies
                    FROM books 
                    WHERE id = ?
                """, (book_id,))
                
                book = cursor.fetchone()
                if book:
                    recommendations.append({
                        'id': book[0],
                        'title': book[1],
                        'author': book[2],
                        'category': book[3],
                        'description': book[4] or 'No description available',
                        'publication_year': book[5],
                        'isbn': book[6],
                        'available_copies': book[7],
                        'total_copies': book[8],
                        'score': round(scores[book_id], 2)
                    })
            
            conn.close()
            return recommendations
        except Exception as e:
            print(f"Error in content-based recommendations: {str(e)}")
            return self.get_popular_books(n)

    def get_similar_books(self, book_id: int, n: int = 5) -> List[Dict[str, Any]]:
        """Get books similar to the given book"""
        # Get all books and their features
        book_features = self.get_book_features()
        
        if book_id not in book_features:
            return []
            
        # Extract book IDs and text features for TF-IDF
        book_ids = list(book_features.keys())
        text_features = [book_features[bid]['text'] for bid in book_ids]
        
        # Create TF-IDF matrix
        try:
            tfidf_matrix = self.vectorizer.fit_transform(text_features)
            
            # Calculate similarity between all books
            similarity_matrix = cosine_similarity(tfidf_matrix)
            
            # Map book IDs to matrix indices
            book_indices = {book_id: idx for idx, book_id in enumerate(book_ids)}
            
            # Get similarity scores for the given book
            book_idx = book_indices[book_id]
            similarity_scores = [(other_id, similarity_matrix[book_idx, book_indices[other_id]]) 
                                for other_id in book_ids if other_id != book_id]
            
            # Sort by similarity
            similarity_scores.sort(key=lambda x: x[1], reverse=True)
            
            # Get top N similar books
            similar_book_ids = [bid for bid, _ in similarity_scores[:n]]
            
            # Get book details
            conn = self.get_db_connection()
            cursor = conn.cursor()
            
            similar_books = []
            for book_id in similar_book_ids:
                cursor.execute("""
                    SELECT id, title, author, category, description,
                           publication_year, isbn, available_copies, total_copies
                    FROM books 
                    WHERE id = ?
                """, (book_id,))
                
                book = cursor.fetchone()
                if book:
                    similar_books.append({
                        'id': book[0],
                        'title': book[1],
                        'author': book[2],
                        'category': book[3],
                        'description': book[4] or 'No description available',
                        'publication_year': book[5],
                        'isbn': book[6],
                        'available_copies': book[7],
                        'total_copies': book[8]
                    })
            
            conn.close()
            return similar_books
            
        except Exception as e:
            print(f"Error in getting similar books: {str(e)}")
            return []

    def get_recommendations(self, user_id: int, n: int = 10) -> Dict[str, List[Dict[str, Any]]]:
        """Get recommendations for a user using multiple algorithms"""
        # Get content-based recommendations
        content_recommendations = self.content_based_recommendations(user_id, n)
        
        # Get popular books
        popular_books = self.get_popular_books(n)
        
        return {
            'content_based': content_recommendations,
            'popular': popular_books
        }
